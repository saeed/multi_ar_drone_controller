//objectTrackingTutorial.cpp

//Written by  Kyle Hounslow 2013

//Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software")
//, to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
//and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
//IN THE SOFTWARE.

#include <OCV/ar_drone_with_localizer.h>
#include <iostream>
using namespace cv;
using namespace std;
//initial min and max HSV filter values.
//these will be changed using trackbars
//int H_MIN = 0;
//int H_MAX = 35;
//int S_MIN = 16;
//int S_MAX = 60;
//int V_MIN = 250;
//int V_MAX = 256;

int H_MIN = 0;
int H_MAX = 256;
int S_MIN = 52;
int S_MAX = 187;
int V_MIN = 235;
int V_MAX = 256;

float currentDroneX = 0.0;
float currentDroneY = 0.0;
//default capture width and height
const int FRAME_WIDTH = 640;
const int FRAME_HEIGHT = 480;
//max number of objects to be detected in frame
const int MAX_NUM_OBJECTS=50;
//minimum and maximum object area
const int MIN_OBJECT_AREA = 20*20;
const int MAX_OBJECT_AREA = FRAME_HEIGHT*FRAME_WIDTH/1.5;
//names that will appear at the top of each window
const string windowName = "Original Image";
const string windowName1 = "HSV Image";
const string windowName2 = "Thresholded Image";
const string windowName3 = "After Morphological Operations";
const char* wndname = "Square Detection Demo";
const string trackbarWindowName = "Trackbars";

Mat image;


struct memoryStruct {
  char *memory;
  size_t size;
};

static void* CURL_realloc(void *ptr, size_t size)
{
  /* There might be a realloc() out there that doesn't like reallocing
     NULL pointers, so we take care of it here */
  if(ptr)
    return realloc(ptr, size);
  else
    return malloc(size);
}

size_t WriteMemoryCallback
(void *ptr, size_t size, size_t nmemb, void *data)
{
  size_t realsize = size * nmemb;
  struct memoryStruct *mem = (struct memoryStruct *)data;

  mem->memory = (char *)
		CURL_realloc(mem->memory, mem->size + realsize + 1);
  if (mem->memory) {
    memcpy(&(mem->memory[mem->size]), ptr, realsize);
    mem->size += realsize;
    mem->memory[mem->size] = 0;
  }
  return realsize;
}




void on_trackbar( int, void* )
{//This function gets called whenever a
	// trackbar position is changed





}
string intToString(int number){


	std::stringstream ss;
	ss << number;
	return ss.str();
}
void createTrackbars(){
	//create window for trackbars


    namedWindow(trackbarWindowName,0);
	//create memory to store trackbar name on window
	char TrackbarName[50];
	sprintf( TrackbarName, "H_MIN", H_MIN);
	sprintf( TrackbarName, "H_MAX", H_MAX);
	sprintf( TrackbarName, "S_MIN", S_MIN);
	sprintf( TrackbarName, "S_MAX", S_MAX);
	sprintf( TrackbarName, "V_MIN", V_MIN);
	sprintf( TrackbarName, "V_MAX", V_MAX);
	//create trackbars and insert them into window
	//3 parameters are: the address of the variable that is changing when the trackbar is moved(eg.H_LOW),
	//the max value the trackbar can move (eg. H_HIGH), 
	//and the function that is called whenever the trackbar is moved(eg. on_trackbar)
	//                                  ---->    ---->     ---->      
    createTrackbar( "H_MIN", trackbarWindowName, &H_MIN, H_MAX, on_trackbar );
    createTrackbar( "H_MAX", trackbarWindowName, &H_MAX, H_MAX, on_trackbar );
    createTrackbar( "S_MIN", trackbarWindowName, &S_MIN, S_MAX, on_trackbar );
    createTrackbar( "S_MAX", trackbarWindowName, &S_MAX, S_MAX, on_trackbar );
    createTrackbar( "V_MIN", trackbarWindowName, &V_MIN, V_MAX, on_trackbar );
    createTrackbar( "V_MAX", trackbarWindowName, &V_MAX, V_MAX, on_trackbar );


}

void morphOps(Mat &thresh){

	//create structuring element that will be used to "dilate" and "erode" image.
	//the element chosen here is a 3px by 3px rectangle

	Mat erodeElement = getStructuringElement( MORPH_RECT,Size(3,3));
    //dilate with larger element so make sure object is nicely visible
	Mat dilateElement = getStructuringElement( MORPH_RECT,Size(12,12));

	erode(thresh,thresh,erodeElement);
	erode(thresh,thresh,erodeElement);


	dilate(thresh,thresh,dilateElement);
	dilate(thresh,thresh,dilateElement);
	


}

// helper function:
// finds a cosine of angle between vectors
// from pt0->pt1 and from pt0->pt2
static double angle( Point pt1, Point pt2, Point pt0 )
{
    double dx1 = pt1.x - pt0.x;
    double dy1 = pt1.y - pt0.y;
    double dx2 = pt2.x - pt0.x;
    double dy2 = pt2.y - pt0.y;
    return (dx1*dx2 + dy1*dy2)/sqrt((dx1*dx1 + dy1*dy1)*(dx2*dx2 + dy2*dy2) + 1e-10);
}



// returns sequence of squares detected on the image.
// the sequence is stored in the specified memory storage
static void findReds( Mat& image, Mat& original)
{


    std::vector<std::vector<cv::Point> > contours;
    std::vector<cv::Vec4i> hierarchy;
 
    findContours(image, contours, CV_RETR_LIST, CV_CHAIN_APPROX_SIMPLE);


    std::vector<std::vector<cv::Point> > contours_poly( contours.size() );

    for( int i = 0; i < contours.size(); i++ )
    { 
        cv::approxPolyDP( cv::Mat(contours[i]), contours_poly[i], 3, true );
	const Point* p = &contours_poly[i][0];
        int n = (int)contours_poly[i].size();
	//polylines(image, &p, &n, 1, true, Scalar(0,255,0), 3, CV_AA);
    }

    vector<Moments> mu(contours_poly.size());
    for (int i = 0; i < contours_poly.size(); i++)
    {
        mu[i] = moments(contours_poly[i], false);
    }

    vector<Point2f> mc (contours_poly.size());
    for (int i = 0; i <contours_poly.size(); i++)
    {

        mc[i] = Point2f(mu[i].m10/mu[i].m00, mu[i].m01/mu[i].m00);
    }


    for( int i = 0; i < contours.size(); i++ )
    {
	circle(original, mc[i], 4, Scalar(255,0,0), -1, 8,0);
    }
    if(mu.size()>0)
    {
        currentDroneX = mu[0].m10/mu[0].m00;
        currentDroneY = mu[0].m01/mu[0].m00;
	//printf("%f   ...  %f \n" , mu[0].m10/mu[0].m00 , mu[0].m01/mu[0].m00 );
    }
    
    //imshow(wndname, original);   
}



void getCurrentLocation(float* x, float* y)
{
    *x = currentDroneX;
    *y = currentDroneY;
}

int main2oo()
{
	return 0;
}

int main2o()
{
	Size S = Size(640,480);    
	VideoWriter outputVideo;                                        // Open the output
	outputVideo.open("camera_up_top.avi", CV_FOURCC('P','I','M','1'), 20, S, true);  

	//CvVideoWriter *writer = cvCreateVideoWriter("cam_cap.avi", CV_FOURCC('x','v','i','d'), 20, S, 1);
    
	if (!outputVideo.isOpened())
	{
		cout  << "Could not open the output video for write: " << endl;
		return -1;
	}




	//some boolean variables for different functionality within this
	//program
	bool trackObjects = false;
	bool useMorphOps = true;
	//Matrix to store each frame of the webcam feed
	Mat cameraFeed;
	//matrix storage for HSV image
	Mat HSV;
	//matrix storage for binary threshold image
	Mat threshold;
	
	
	CURL *curl;       // CURL objects
	CURLcode res;
	cv::Mat image, dst; 	// image object
	memoryStruct buffer; // memory buffer

	curl = curl_easy_init(); // init CURL library object/structure

	while(1){
		//store image to matrix
		//capture.read(cameraFeed);
		//convert frame from BGR to HSV colorspace

		buffer.memory = NULL;
	        buffer.size = 0;
		//cout << "#################### 1\n";
	        // (N.B. check this URL still works in browser in case image has moved)

	        curl_easy_setopt(curl, CURLOPT_URL, "http://192.168.200.102/axis-cgi/jpg/image.cgi");
	        //curl_easy_setopt(curl, CURLOPT_VERBOSE, 1); // tell us what is happening

	        // tell libcurl where to write the image (to a dynamic memory buffer)

	        curl_easy_setopt(curl,CURLOPT_WRITEFUNCTION, WriteMemoryCallback);
	        curl_easy_setopt(curl,CURLOPT_WRITEDATA, (void *) &buffer);
	
	        // get the image from the specified URL

	        res = curl_easy_perform(curl);

	        // decode memory buffer using OpenCV
		//cout << "#################### 2\n";
	        image = cv::imdecode(cv::Mat(1, buffer.size, CV_8UC1, buffer.memory), CV_LOAD_IMAGE_UNCHANGED);
		

		cvtColor(image,HSV,COLOR_BGR2HSV);
		//filter HSV image between values and store filtered image to
		//threshold matrix


		inRange(HSV,Scalar(H_MIN,S_MIN,V_MIN),Scalar(H_MAX,S_MAX,V_MAX),threshold);
		//perform morphological operations on thresholded image to eliminate noise
		//and emphasize the filtered object(s)
		if(useMorphOps)
			morphOps(threshold);
		//pass in thresholded frame to our object tracking function
		//this function will return the x and y coordinates of the
		//filtered object
		//cout << "#################### 3\n";

		findReds(threshold, image);
		//show frames 
		//imshow(windowName2,threshold);
		//imshow(windowName,cameraFeed);
		//imshow(windowName1,HSV);
		cv::resize(image,image,cv::Size(640,480));
		outputVideo << image;

		//delay 30ms so that screen can refresh.
		//image will not appear without this waitKey() command
		waitKey(30);
	}






	return 0;
}

